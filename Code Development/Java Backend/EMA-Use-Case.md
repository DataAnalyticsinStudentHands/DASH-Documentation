**NOTE: If you are not familar with the scheduling functionality of Quartz and the `java.util.Timer` class, please read the documentation under [Scheduling-and-Quartz.md](Scheduling-and-Quartz.md)**

#EMA Use Case
Some use cases require us to schedule events for execution in the future. To accomplish this, we utilze both [`java.util.Timer` and the Quartz Scheduling Library](Scheduling-and-Quartz.md). The main example of this in our applications is the EMA use case. In this application, a user can define a specific set of times that other users must fill out a form. The users filling out the form will be alerted in some way, such as email, text or push notifications. The first step in this process is for the user to input the data about when a form should be filled out. This data is stored in instances of the `Study` class. This class holds the timing information as well as a list of users who should receive the form. It also includes a member variable, `startDate`, which is the first day the forms should be made available to the users.

##Scheduling Studies
After a user creates a study through the front in, the information must be used to schedule an event. This scheduling is done by the `DailyInitTask` class. This class extends `TimerTask` and schedules a `StudyJob` for each study. The `QuartzInitServletContextListener` class implements the [`ServletContextListener`](http://www.deadcoderising.com/execute-code-on-webapp-startup-and-shutdown-using-servletcontextlistener/). Without going into detail, the `ServletContextListener` interface has two methods. `contextInitialized()` will run whenever the web application is started, and `contextDestroyed()` will run whenever the web application is shutdown. In the `contextInitialize()` method, a `DailyInitTask` instance is schedule for execution every night near midnight. The `run()` method of this class queries the database for all studies beginning on the next day. The `generateCronStrings()` method is called for each study, and the resulting cron strings are used to generate `CronTrigger` instances to be attached to a `StudyJob` instance.

##StudyJob
The `StudyJob` class extends the `QuartzJobBean` abstract class, which implements the `Job` interface from Quartz. We extend this class rather than directly implenting the `Job` interface to allow the job access to the Spring Context. This is needed to acquire beans at the Service and Dao layer for use in the job. In this class, the `executeInternal()` method serves as the `execute()` method from the `Job` interface. This job contains a studyId, formId, and a list of participants in the study. The `executeInternal()` method simply activates the form for the users in the `participants` list by adding the formId and studyId to the `activeStudies` map in the user object. If a studyId and its associated formId are present in a user's `activeStudies` map, then that form and study are said to be "active" for that user. After activating the study, all the users are alerted based on their preferences that they have a form to reply too. 

##Expiring Studies
When a study is activated by an execution of a `StudyJob`, it's expiration time is also calculated and stored. This is done by adding the number of hours given by the duration variable to the current time. That is, if a `StudyJob` is executed at 3pm, and the duration variable of the `Study` object has a value of 3, then the expiration time is caluclated as 6pm that day. This is stored along with the associated studyId in the **expiration_times** table in the database. Similarly to how jobs are scheduled, a `Timer` schedules an instance of `TimeoutTask` for execution every five minutes, starting in five minutes. The `run()` method of this task queries the database for any entires in the **expiration_times** table with dates before now. It then removes the studyIds matched with those dates from every user's `activeStudies` map, thus "de-activating" the study. The expired dates are also removed from the database to prevent them from being retrieved by the next query in five minutes.

**WARNING:** Rather than start the `TimeoutTask` immediently, the first execution is scheduled for five minutes after the server is started. This delay is to prevent an error. Because `Timer` instances execute in a separate thread, it processes independently of the other threads. Just like in the `DailyInitTask` and `StudyJob` class, the `TimeoutTask` needs access to Service and Dao layer beans. If the `Timer` thread attempts to access the Spring Context before the server has finished, a `java.lang.IllegalStateException: No WebApplicationContext found` exception will be thrown, because the WebApplicationContext has not finished initalizing. The five minute delay prevents this from happening.

##Timers vs Quartz
Although the Quartz library is more powerful and flexible than the `Timer` class, we have elected to use both rather than just one. Both uses of the `Timer` class were decided for the same reason. Both the `TimeoutTask` and `DailyInitTask` usages must consistently be running at all times. However, these events must be scheduled in some way. If we were to use a Quartz `Job` implementation, the jobs would be persisted and rescheduled whenever the server is restarted. This would mean we could start them once and just leave them running. However, it is difficult write code that works only once. This code would have to be able to identify if the job already exists in the database, and then schedule it if its not. While not impossible, it makes since to just use a non-persistent scheduling implementation. Because these events are simple and can be scheduled to run indefitinely on a fixed delay, the `Timer` class provides sufficient capabilites. The `StudyJob` however is too complicated to be done using only `Timer` instances. These events need to be dynamic and flexible, which is why they utilize the Quartz Library rather than `Timer` instances.